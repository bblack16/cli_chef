require_relative 'cabinet'
require_relative 'recipe_book'

module CLIChef

  class Cookbook
    attr_reader :name, :description, :path, :valid, :result
    attr_reader :cabinet, :exit_codes, :default_locations, :recipe_book

    def initialize name, description:nil, path: nil
      init name, description, path
    end

<<<<<<< HEAD
    def run *ingredients
      valid_check
      @result = ({response: `#{prepare(ingredients.find{|i| Hash === i})}`, exit: {code: $?.exitstatus, desc: @exit_codes[$?.exitstatus]}})
      return @result
    end

    def prepare ingredients
=======
    def run **ingredients
      valid_check
      @result = ({response: `#{prepare(ingredients)}`, exit: {code: $?.exitstatus, desc: @exit_codes[$?.exitstatus]}})
      return @result
    end

    def prepare **ingredients
>>>>>>> 896d203583c4558e650a861afc52a50df6c6c37e
      "#{get_path} #{@cabinet.ingredient_string(ingredients)}"
    end

    def name= n
      @name = n.to_s
    end

    def description= d
      @description = d.to_s
    end

    def path= p
      @path = p.to_s
      check_path
    end

    def valid?
      @valid == true
    end

    def ingredient_list
      @cabinet.ingredients.keys
    end

    def ingredient_options name
      return nil unless @cabinet.ingredients.include? name
      @cabinet.ingredients[name].allowed_values
    end

    def ingredient name
      @cabinet.ingredients[name]
    end

    def add_ingredient ingredient
      @cabinet.add_ingredient(ingredient)
    end

    def remove_ingredient name
      @cabinet.remove_ingredient(name)
    end

    def add_recipe r
      @recipe_book.add_recipe r
    end

    def remove_recipe name
      @recipe_book.remove_recipe name
    end

<<<<<<< HEAD
    def cook recipe, ingredients = {}
=======
    def cook recipe, **ingredients
>>>>>>> 896d203583c4558e650a861afc52a50df6c6c37e
      return nil unless @recipe_book.include? recipe.to_sym
      run(@recipe_book[recipe.to_sym].mix(ingredients))
    end

<<<<<<< HEAD
    def preheat recipe, ingredients = {}
=======
    def preheat recipe, **ingredients
>>>>>>> 896d203583c4558e650a861afc52a50df6c6c37e
      return nil unless @recipe_book.include? recipe.to_sym
      prepare(@recipe_book[recipe.to_sym].mix(ingredients))
    end

    def recipe_list
      @recipe_book.recipes.keys
    end

    def menu ingredients: true, recipes: true
      menu = %"
      ▄████████  ▄█        ▄█        ▄████████    ▄█    █▄       ▄████████    ▄████████
     ███    ███ ███       ███       ███    ███   ███    ███     ███    ███   ███    ███
     ███    █▀  ███       ███▌      ███    █▀    ███    ███     ███    █▀    ███    █▀
     ███        ███       ███▌      ███         ▄███▄▄▄▄███▄▄  ▄███▄▄▄      ▄███▄▄▄
     ███        ███       ███▌      ███        ▀▀███▀▀▀▀███▀  ▀▀███▀▀▀     ▀▀███▀▀▀
     ███    █▄  ███       ███       ███    █▄    ███    ███     ███    █▄    ███
     ███    ███ ███▌    ▄ ███       ███    ███   ███    ███     ███    ███   ███
     ████████▀  █████▄▄██ █▀        ████████▀    ███    █▀      ██████████   ███
                ▀\n"
      menu+= "\t\t\tMenu for #{@name}\n\n" + '-'*50 + "\nCurrent location:' #{@path}'\n\n"
      if recipes
        menu+= '/'*50 + "\n\tAvailable Recipes\n" + "\\"*50
        @recipe_book.recipes.each do |n, r|
          menu+= "\n\n" + '-'*35 + "\n\t\t#{n}\n" + '-'*35 + "\n" + r.description + "\n\nIngredient List:"
          r.ingredients.each{|n, i| menu+= "\n\t\t - #{n}#{r.required_input.include?(n) ? ' (*required)' : nil} = #{i}"}
        end
      end
      if ingredients
        menu+= "\n\n" + "/"*50 + "\n\tGlobal Ingredient List\n" + "\\"*50 + "\n"
        @cabinet.ingredients.each do |n, i|
          menu+= "\n\t\t#{n}  - #{i.description}\n\t\t\tAllowed Values: #{i.allowed_values}\n\t\t\tFlag:'#{i.flag}'\n\t\t\tDefault: '#{i.default}'\n\t\t\tAliases: #{i.aliases.join(', ')}\n\t\t\tSpacer: '#{i.spacer}'\n\t\t\tEncapsulator: '#{i.encapsulator}'\n"
        end
      end
      menu+= '-'*50 + "\nMenu Generated by the CLI Chef. Part of the BBLib libraries."
      menu
    end

    protected

      def init name, description, path
        @exit_codes, @default_locations = {}, []
        @recipe_book = CLIChef::RecipeBook.new
        @cabinet = CLIChef::Cabinet.new
        self.name = name
        self.description = description
        self.setup_ingredients
        self.setup_exit_codes
        self.setup_default_locations
        self.setup_recipes
        self.setup_other
        if path.nil?
          self.path = get_path_from_defaults
        else
          self.path = path
        end
      end

      def check_path
        @valid = File.exist? @path
<<<<<<< HEAD
        if !@valid
          begin
            `#{@path}`
            @valid = true
          rescue
            @valid = false
          end
        end
        @valid
=======
        valid
>>>>>>> 896d203583c4558e650a861afc52a50df6c6c37e
      end

      def get_path_from_defaults
        @default_locations.each do |l|
          if File.exist? l
            return l
          end
        end
        nil
      end

      def valid_check
<<<<<<< HEAD
        raise "This wrapper cannot be run because no valid path to the exe was found (#{@name}). Current path: '#{@path}'" unless @valid
=======
        raise "This wrapper cannot be run because no valid path to the exe was found (#{@name})." unless @valid
>>>>>>> 896d203583c4558e650a861afc52a50df6c6c37e
      end

      def setup_ingredients
        raise "This class (#{self.class}) did not reimplement the setup_ingredients method. Failure on the programers part..."
      end

      def setup_exit_codes
        @exit_codes = {0 => "Clean exit."}
      end

      def setup_default_locations
        # Nothing happens in base class. Use this to add locations to defaults.
      end

      def setup_recipes
        # Base class has no recipes. This can be used to add default recipes to the Cookbook.
      end

      def setup_other
        # base class does nothing with this
      end

      def get_path
        if @path.include? ' '
          "\"#{@path}\""
        else
          @path
        end
      end
  end

end
