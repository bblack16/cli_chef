require_relative 'cabinet'
require_relative 'recipe_book'

module BBLib

  module CLIChef

    class Cookbook
      attr_reader :name, :description, :path, :valid, :result
      attr_reader :cabinet, :exit_codes, :default_locations, :recipe_book

      def initialize name, description:nil, path: nil
        init name, description, path
      end

      def run *ingredients
        valid_check
        @result = ({response: `#{prepare(ingredients.find{|i| Hash === i})}`, exit: {code: $?.exitstatus, desc: @exit_codes[$?.exitstatus]}})
        return @result
      end

      def prepare ingredients
        "#{get_path} #{@cabinet.ingredient_string(ingredients)}"
      end

      def name= n
        @name = n.to_s
      end

      def description= d
        @description = d.to_s
      end

      def path= p
        @path = p.to_s
        check_path
      end

      def valid?
        @valid == true
      end

      def ingredient_list
        @cabinet.ingredients.keys
      end

      def ingredient_options name
        return nil unless @cabinet.ingredients.include? name
        @cabinet.ingredients[name].allowed_values
      end

      def ingredient name
        @cabinet.ingredients[name]
      end

      def add_ingredient ingredient
        @cabinet.add_ingredient(ingredient)
      end

      def remove_ingredient name
        @cabinet.remove_ingredient(name)
      end

      def add_recipe r
        @recipe_book.add_recipe r
      end

      def remove_recipe name
        @recipe_book.remove_recipe name
      end

      def cook recipe, ingredients = {}
        return nil unless @recipe_book.include? recipe.to_sym
        run(@recipe_book[recipe.to_sym].mix(ingredients))
      end

      def preheat recipe, ingredients = {}
        return nil unless @recipe_book.include? recipe.to_sym
        prepare(@recipe_book[recipe.to_sym].mix(ingredients))
      end

      def recipe_list
        @recipe_book.recipes.keys
      end

      def menu ingredients: true, recipes: true
        menu = %"
        ▄████████  ▄█        ▄█        ▄████████    ▄█    █▄       ▄████████    ▄████████
       ███    ███ ███       ███       ███    ███   ███    ███     ███    ███   ███    ███
       ███    █▀  ███       ███▌      ███    █▀    ███    ███     ███    █▀    ███    █▀
       ███        ███       ███▌      ███         ▄███▄▄▄▄███▄▄  ▄███▄▄▄      ▄███▄▄▄
       ███        ███       ███▌      ███        ▀▀███▀▀▀▀███▀  ▀▀███▀▀▀     ▀▀███▀▀▀
       ███    █▄  ███       ███       ███    █▄    ███    ███     ███    █▄    ███
       ███    ███ ███▌    ▄ ███       ███    ███   ███    ███     ███    ███   ███
       ████████▀  █████▄▄██ █▀        ████████▀    ███    █▀      ██████████   ███
                  ▀\n"
        menu+= "\t\t\tMenu for #{@name}\n\n" + '-'*50 + "\nCurrent location:' #{@path}'\n\n"
        if recipes
          menu+= '/'*50 + "\n\tAvailable Recipes\n" + "\\"*50
          @recipe_book.recipes.each do |n, r|
            menu+= "\n\n" + '-'*35 + "\n\t\t#{n}\n" + '-'*35 + "\n" + r.description + "\n\nIngredient List:"
            r.ingredients.each{|n, i| menu+= "\n\t\t - #{n}#{r.required_input.include?(n) ? ' (*required)' : nil} = #{i}"}
          end
        end
        if ingredients
          menu+= "\n\n" + "/"*50 + "\n\tGlobal Ingredient List\n" + "\\"*50 + "\n"
          @cabinet.ingredients.each do |n, i|
            menu+= "\n\t\t#{n}  - #{i.description}\n\t\t\tAllowed Values: #{i.allowed_values}\n\t\t\tFlag:'#{i.flag}'\n\t\t\tDefault: '#{i.default}'\n\t\t\tAliases: #{i.aliases.join(', ')}\n\t\t\tSpacer: '#{i.spacer}'\n\t\t\tEncapsulator: '#{i.encapsulator}'\n"
          end
        end
        menu+= '-'*50 + "\nMenu Generated by the CLI Chef. Part of the BBLib libraries."
        menu
      end

      protected

        def init name, description, path
          @exit_codes, @default_locations = {}, []
          @recipe_book = BBLib::CLIChef::RecipeBook.new
          @cabinet = BBLib::CLIChef::Cabinet.new
          self.name = name
          self.description = description
          self.setup_ingredients
          self.setup_exit_codes
          self.setup_default_locations
          self.setup_recipes
          self.setup_other
          if path.nil?
            self.path = get_path_from_defaults
          else
            self.path = path
          end
        end

        def check_path
          @valid = File.exist? @path
          valid
        end

        def get_path_from_defaults
          @default_locations.each do |l|
            if File.exist? l
              return l
            end
          end
          nil
        end

        def valid_check
          raise "This wrapper cannot be run because no valid path to the exe was found (#{@name})." unless @valid
        end

        def setup_ingredients
          raise "This class (#{self.class}) did not reimplement the setup_ingredients method. Failure on the programers part..."
        end

        def setup_exit_codes
          @exit_codes = {0 => "Clean exit."}
        end

        def setup_default_locations
          # Nothing happens in base class. Use this to add locations to defaults.
        end

        def setup_recipes
          # Base class has no recipes. This can be used to add default recipes to the Cookbook.
        end

        def setup_other
          # base class does nothing with this
        end

        def get_path
          if @path.include? ' '
            "\"#{@path}\""
          else
            @path
          end
        end
    end

  end

end
